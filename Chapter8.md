---
title: "SQL Chapter 8"
author: "db"
---






















<br><br><br><br><br><br><br><br><br><br><br><br>
<html><head><meta http-equiv="Content-Type" content="text/html;charset=utf-8" /><link href="style.css" rel="stylesheet" type="text/css" /><title>SQL for Data Scientists: A Beginner's Guide for Building Datasets for Analysis</title></head><body><div type="bodymatter" class="calibre1" id="calibre_link-0">

  <section aria-labelledby="c08_1" type="chapter" role="doc-chapter" class="calibre2">

    <header class="calibre3">

      <h1 id="calibre_link-31" class="calibre4"><span aria-label="113" type="pagebreak" id="calibre_link-32" role="doc-pagebreak" class="calibre5"></span><a id="calibre_link-33" class="calibre6"></a><span class="calibre">CHAPTER 8</span><br class="calibre7" /><span class="calibre">Date and Time Functions</span></h1>

    </header>

    <section aria-label="chapter opening" class="calibre2"><span id="calibre_link-34" class="calibre"></span>
<p id="calibre_link-35" class="calibre8">Data scientists use date and time functions many different ways in our queries. We may use two dates to calculate a duration, for example. Many machine learning algorithms are “trained” to identify patterns in data from the past and use those patterns to predict future outcomes. In order to build a dataset for that purpose, we have to be able to filter queries by time range.</p>
<p id="calibre_link-36" class="calibre8">Often, datasets that are built for predictive models include summaries of activities within dynamic date ranges&mdash;for example, a count of some activity occurrence during each of the past three months. Or, in the case of time-series analysis, an input dataset might include one row per time period (hour, day, week, month) with a count of something associated with each time period; for example, the number of patients a doctor sees per week.</p>
<p id="calibre_link-37" class="calibre8">Many predictive models are time-bound. For example, the question “Will this first-time customer become a repeat customer?” will be further refined as “What is the likelihood that each first-time customer at today's farmer’s market will return and make a second purchase within the next month?” To answer this question, we could create a dataset with a row for every customer, columns containing data values as of the time of their first purchase, and a binary “target variable” that indicates whether that customer made another purchase within a month of their first purchase date.</p>
<p id="calibre_link-38" class="calibre8">Let's look at some different ways to work with date and time values in our Farmer's Market database.</p>
</section>

    <section aria-labelledby="head-2-60" class="calibre2"><span id="calibre_link-39" class="calibre"></span>
<h2 id="calibre_link-40" class="calibre9">Setting datetime Field Values</h2>
<p class="calibre8"><span aria-label="114" type="pagebreak" id="calibre_link-41" role="doc-pagebreak" class="calibre10"></span>The Farmer's Market 
<code class="calibre11">market_date_info</code>
 table doesn't include any fields stored as datetime values, so in order to demonstrate date and time functions without having to combine fields in every query, I'm going to first create a demonstration table with datetimes created by combining the 
<code class="calibre11">market_date</code>
 and 
<code class="calibre11">market_start_time</code>
 fields in the 
<code class="calibre11">market_date_info</code>
 table using the following query:</p>
<pre id="calibre_link-42" class="calibre12">
<code class="calibre11">CREATE TABLE farmers_market.datetime_demo AS</code>
<code class="calibre11">(</code>
    
<code class="calibre11"> SELECT market_date, </code>
        
<code class="calibre11"> market_start_time, </code>
        
<code class="calibre11"> market_end_time,</code>
        
<code class="calibre11"> STR_TO_DATE(CONCAT(market_date, ' ', market_start_time), '%Y-%m-%d %h:%i %p') </code>
            
<code class="calibre11"> AS market_start_datetime,</code>
        
<code class="calibre11"> STR_TO_DATE(CONCAT(market_date, ' ', market_end_time), '%Y-%m-%d %h:%i %p') </code>
            
<code class="calibre11"> AS market_end_datetime</code>
    
<code class="calibre11"> FROM farmers_market.market_date_info</code>
<code class="calibre11">)</code>
</pre>
<p id="calibre_link-43" class="calibre8">We will go over table creation in <a href="c14.xhtml" class="calibre6">Chapter 14</a>, “Storing Machine Learning Results,” but I want to explain what the functions here are doing. Refer to <a href="#calibre_link-1" id="calibre_link-2" class="calibre6">Figure 8.1</a> to see data in the table generated by this query.</p>
<figure class="calibre13">
<figcaption class="calibre14">
<p class="calibre8"><span class="figurelabel"><a href="#calibre_link-2" id="calibre_link-1" role="doc-backlink" class="calibre6">Figure 8.1</a></span></p>
</figcaption>
</figure>
<p id="calibre_link-44" class="calibre8">The innermost part of the nested functions in the line of the query used to create the 
<code class="calibre11">market_start_datetime</code>
 field concatenates the 
<code class="calibre11">market_date</code>
 and 
<code class="calibre11">market_start_time</code>
 into a single string value, using 
<code class="calibre11">CONCAT()</code>
. The surrounding 
<code class="calibre11">STR_TO_DATE()</code>
 function, as you might guess, converts string values to date values. The string of percent signs and letters in single quotes at the end is an input parameter that tells the function how the date and time are formatted.</p>
<p class="calibre8">
<code class="calibre11">%Y</code>
 is a 4-digit year, 
<code class="calibre11">%m</code>
 is a 2-digit month, 
<code class="calibre11">%d</code>
 is a 2-digit day, 
<code class="calibre11">%h</code>
 is the hour, 
<code class="calibre11">%i</code>
 represents the minutes, and 
<code class="calibre11">%p</code>
 indicates there is an AM/PM indicator in the time string. Every database system has some codes for the date and time formatting, which can be found in the documentation, but these values are common, originating from the C programming language.<span aria-label="115" type="pagebreak" id="calibre_link-45" role="doc-pagebreak" class="calibre10"></span></p>
<aside class="calibre15">
<div class="top"><hr class="calibre16" /></div>
<section class="feature">
<h3 class="calibre17">NOTE</h3>
<p id="calibre_link-46" class="calibre18">You can find the SQL date and time function documentation for any database system by searching the internet for “[database system] date and time functions.” For MySQL 8.0, you can find this documentation at <a class="code" href="http://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html">dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html</a>.</p>
<div class="top"><hr class="calibre16" /></div>
</section>
</aside>
<p id="calibre_link-47" class="calibre8">The combination of functions in the query associated with <a href="#calibre_link-1" class="calibre6">Figure 8.1</a> is taking each date and time string, concatenating them into a combined datetime string, and converting that to a datetime data type. So, the final 
<code class="calibre11">market_start_datetime</code>
 and 
<code class="calibre11">market_end_datetime</code>
 fields are actually stored as datetime values, which we can then use to perform calculations, like finding the difference between two datetimes. The 
<code class="calibre11">STR_TO_DATE()</code>
 function does the type conversion to a date, time, or datetime, depending on the input. It will return a NULL value if the input string isn't formatted in a way it can interpret.</p>
<p id="calibre_link-48" class="calibre8">You'll notice that the dates in the final two columns in <a href="#calibre_link-1" class="calibre6">Figure 8.1</a> are formatted as YYYY-MM-DD, and the times are in 24-hour time (HH:MM:SS), which is one indication that the fields are datetimes (though I should note it would also be possible to format a string to look like a datetime using the 
<code class="calibre11">DATE_FORMAT()</code>
 function and a particular formatting string).</p>
</section>

    <section aria-labelledby="head-2-61" class="calibre2"><span id="calibre_link-49" class="calibre"></span>
<h2 id="calibre_link-50" class="calibre9">EXTRACT and DATE_PART</h2>
<p id="calibre_link-51" class="calibre8">You will encounter datetime data types, such as timestamps, in the databases you work with and might only need a portion of the stored date and time value. For example, you might only want the month and day from a full date, in one field, with the year stripped out into a second field, to create a year-over-year comparison (to align and visualize daily totals from different years by month and day).</p>
<p id="calibre_link-52" class="calibre8">Depending on the database system you are using, the function that retrieves different portions of a datetime value may be called 
<code class="calibre11">EXTRACT</code>
 (MySQL), 
<code class="calibre11">DATE_PART</code>
 (Redshift), or 
<code class="calibre11">DATEPART</code>
 (Oracle and SQL Server). The example Farmer's Market database is in MySQL, so these examples use 
<code class="calibre11">EXTRACT()</code>
, but the concepts are the same for the other functions, even though the syntax will vary. The 
<code class="calibre11">market_start_datetime</code>
 field in <a href="#calibre_link-3" id="calibre_link-4" class="calibre6">Figure 8.2</a> is an example of a MySQL datetime type field.</p>
<p id="calibre_link-53" class="calibre8">In addition to 
<code class="calibre11">EXTRACT()</code>
, MySQL offers the functions 
<code class="calibre11">DATE()</code>
 and 
<code class="calibre11">TIME()</code>
 to extract the date and time parts of a datetime field, respectively (you put the datetime value inside the parentheses, and just the date or time portion is returned).</p>
<p id="calibre_link-54" class="calibre8">Using datetime values established in the 
<code class="calibre11">datetime_demo</code>
 table created in the previous section, we can 
<code class="calibre11">EXTRACT</code>
 date and time parts from the fields.</p>
<p class="calibre8">The following query demonstrates five different “date parts” that can be extracted from the datetime and results in the output shown in <a href="#calibre_link-3" class="calibre6">Figure 8.2</a>. Using <span aria-label="116" type="pagebreak" id="calibre_link-55" role="doc-pagebreak" class="calibre10"></span>the time intervals allowed by the database system (see the documentation for others), you can extract portions of a datetime field as needed:</p>
<pre id="calibre_link-56" class="calibre12">
<code class="calibre11">SELECT market_start_datetime,</code>
   
<code class="calibre11"> EXTRACT(DAY FROM market_start_datetime) AS mktsrt_day,</code>
   
<code class="calibre11"> EXTRACT(MONTH FROM market_start_datetime) AS mktsrt_month,</code>
   
<code class="calibre11"> EXTRACT(YEAR FROM market_start_datetime) AS mktsrt_year,</code>
   
<code class="calibre11"> EXTRACT(HOUR FROM market_start_datetime) AS mktsrt_hour,</code>
   
<code class="calibre11"> EXTRACT(MINUTE FROM market_start_datetime) AS mktsrt_minute</code>
<code class="calibre11"> FROM farmers_market.datetime_demo</code>
<code class="calibre11"> WHERE market_start_datetime = '2019-03-02 08:00:00'</code>
</pre>
<figure class="calibre13">
<img alt="A table records market start time, day, month, year, hour, minute." class="center" src="images/000000.png" />
<figcaption class="calibre14">
<p class="calibre8"><span class="figurelabel"><a href="#calibre_link-4" id="calibre_link-3" role="doc-backlink" class="calibre6">Figure 8.2</a></span></p>
</figcaption>
</figure>
<p class="calibre8">There are also shortcuts for extracting the entire date and entire time from the datetime field, so you don't have to extract each part and re-concatenate it together. The following query and the output in <a href="#calibre_link-5" id="calibre_link-6" class="calibre6">Figure 8.3</a> demonstrate the 
<code class="calibre11">DATE()</code>
 and 
<code class="calibre11">TIME()</code>
 functions:</p>
<pre id="calibre_link-57" class="calibre12">
<code class="calibre11">SELECT market_start_datetime,</code>
   
<code class="calibre11"> DATE(market_start_datetime) AS mktsrt_date,</code>
   
<code class="calibre11"> TIME(market_start_datetime) AS mktsrt_time</code>
<code class="calibre11">FROM farmers_market.datetime_demo</code>
<code class="calibre11">WHERE market_start_datetime = '2019-03-02 08:00:00'</code>
</pre>
<figure class="calibre13">
<img alt="A table records market start date and time." class="center" src="images/000001.png" />
<figcaption class="calibre14">
<p class="calibre8"><span class="figurelabel"><a href="#calibre_link-6" id="calibre_link-5" role="doc-backlink" class="calibre6">Figure 8.3</a></span></p>
</figcaption>
</figure>
</section>

    <section aria-labelledby="head-2-62" class="calibre2"><span id="calibre_link-58" class="calibre"></span>
<h2 id="calibre_link-59" class="calibre9">DATE_ADD and DATE_SUB</h2>
<p id="calibre_link-60" class="calibre8">The powerful thing about storing string dates as datetime values (or converting them using SQL) is that you can do date calculations, which is not possible when they are stored as numbers and punctuation and letters in a string field. Date math can get complex when dealing with multiple time zones, so in this case we're assuming that all datetimes we're working with are from the same time zone. Here, we'll use the 
<code class="calibre11">market_start_datetime</code>
 and 
<code class="calibre11">market_end_datetime</code>
 fields to demonstrate.</p>
<p class="calibre8">If you wanted to determine how many sales occurred within the first 30 minutes after the farmer’s market opened, how would you dynamically determine what cutoff time to use (automatically calculate it for every market date in your database)? This is where the 
<code class="calibre11">DATE_ADD</code>
 function comes in. We can use SQL to <span aria-label="117" type="pagebreak" id="calibre_link-61" role="doc-pagebreak" class="calibre10"></span>add 30 minutes to the start time by passing the datetime, the interval (minutes, in this case), and the number of minutes we want to add into the 
<code class="calibre11">DATE_ADD</code>
 function, as shown in the second line of the following query:</p>
<pre id="calibre_link-62" class="calibre12">
<code class="calibre11">SELECT market_start_datetime,</code>
   
<code class="calibre11"> DATE_ADD(market_start_datetime, INTERVAL 30 MINUTE) AS mktstrt_date_plus_30min</code>
<code class="calibre11">FROM farmers_market.datetime_demo</code>
<code class="calibre11">WHERE market_start_datetime = '2019-03-02 08:00:00'</code>
</pre>
<p id="calibre_link-63" class="calibre8">I filtered the results to a single market date for clarity. You can see in <a href="#calibre_link-7" id="calibre_link-8" class="calibre6">Figure 8.4</a> that the calculated 
<code class="calibre11">mktstrt_date_plus_30min</code>
 is 30 minutes after the displayed 
<code class="calibre11">market_start_datetime</code>
.</p>
<figure class="calibre13">
<img alt="A table records market start date and time." class="center" src="images/000002.png" />
<figcaption class="calibre14">
<p class="calibre8"><span class="figurelabel"><a href="#calibre_link-8" id="calibre_link-7" role="doc-backlink" class="calibre6">Figure 8.4</a></span></p>
</figcaption>
</figure>
<p class="calibre8">If we instead wanted to do a calculation that required looking 30 days past a date (like the example analysis mentioned in the introduction, which would require calculating 30 days past a customer's first purchase to determine if they made a second purchase within that time frame), we could change the interval parameter from 
<code class="calibre11">MINUTE</code>
 to 
<code class="calibre11">DAY</code>
, and add 30 days instead:</p>
<pre id="calibre_link-64" class="calibre12">
<code class="calibre11">SELECT market_start_datetime,</code>
   
<code class="calibre11"> DATE_ADD(market_start_datetime, INTERVAL 30 DAY) AS mktstrt_date_plus_30days</code>
<code class="calibre11">FROM farmers_market.datetime_demo</code>
<code class="calibre11">WHERE market_start_datetime = '2019-03-02 08:00:00'</code>
</pre>
<p id="calibre_link-65" class="calibre8">You can see in <a href="#calibre_link-9" id="calibre_link-10" class="calibre6">Figure 8.5</a> that the calculated 
<code class="calibre11">mktstrt_date_plus_30min</code>
 is 30 days after 
<code class="calibre11">market_start_datetime</code>
.</p>
<figure class="calibre13">
<img alt="A table records market start date and time." class="center" src="images/000003.png" />
<figcaption class="calibre14">
<p class="calibre8"><span class="figurelabel"><a href="#calibre_link-10" id="calibre_link-9" role="doc-backlink" class="calibre6">Figure 8.5</a></span></p>
</figcaption>
</figure>
<p class="calibre8">There is also a related function called 
<code class="calibre11">DATE_SUB()</code>
 that subtracts intervals from datetimes. However, instead of switching to 
<code class="calibre11">DATE_SUB()</code>
, you could also just add a negative number to the datetime if you prefer. The following query demonstrates that using 
<code class="calibre11">DATE_ADD()</code>
 to add &ndash;30 days to a date has the same effect as using 
<code class="calibre11">DATE_SUB()</code>
 to subtract 30 days from a date, and the results are shown in <a href="#calibre_link-11" id="calibre_link-12" class="calibre6">Figure 8.6</a>:</p>
<pre id="calibre_link-66" class="calibre12"><span aria-label="118" type="pagebreak" id="calibre_link-67" role="doc-pagebreak" class="calibre10"></span>
<code class="calibre11">SELECT market_start_datetime,</code>
   
<code class="calibre11"> DATE_ADD(market_start_datetime, INTERVAL -30 DAY) AS mktstrt_date_plus_neg30days,</code>
   
<code class="calibre11"> DATE_SUB(market_start_datetime, INTERVAL 30 DAY) AS mktstrt_date_minus_30days</code>
<code class="calibre11">FROM farmers_market.datetime_demo</code>
<code class="calibre11">WHERE market_start_datetime = '2019-03-02 08:00:00'</code>
</pre>
<figure class="calibre13">
<img alt="A table records market start date time, market date plus negative 30 days, and market date minus 30 days." class="center" src="images/000004.png" />
<figcaption class="calibre14">
<p class="calibre8"><span class="figurelabel"><a href="#calibre_link-12" id="calibre_link-11" role="doc-backlink" class="calibre6">Figure 8.6</a></span></p>
</figcaption>
</figure>
</section>

    <section aria-labelledby="head-2-63" class="calibre2"><span id="calibre_link-68" class="calibre"></span>
<h2 id="calibre_link-69" class="calibre9">DATEDIFF</h2>
<p id="calibre_link-70" class="calibre8">In the previous section we added 30 days to a date using 
<code class="calibre11">DATE_ADD()</code>
, and I mentioned that the result could be used to determine if an action occurs within 30 days of the first purchase date. However, there is another way to determine whether two dates are within 30 days of one another: 
<code class="calibre11">DATEDIFF()</code>
!</p>
<p id="calibre_link-71" class="calibre8">
<code class="calibre11">DATEDIFF</code>
 is a SQL function available in most database systems that accepts two dates or datetime values, and returns the difference between them in days.</p>
<p class="calibre8">Here, the inner query (by which I mean the query inside parentheses, aliased “x”) returns the first and last market dates from the 
<code class="calibre11">datetime_demo</code>
 table, and the outer query (which is selecting from “x”) calculates the difference between those two dates using 
<code class="calibre11">DATEDIFF</code>
. The output of this query is shown in <a href="#calibre_link-13" id="calibre_link-14" class="calibre6">Figure 8.7</a>:</p>
<pre id="calibre_link-72" class="calibre12">
<code class="calibre11">SELECT </code>
   
<code class="calibre11"> x.first_market, </code>
   
<code class="calibre11"> x.last_market, </code>
   
<code class="calibre11"> DATEDIFF(x.last_market, x.first_market) days_first_to_last</code>
<code class="calibre11">FROM</code>
<code class="calibre11">(</code>
   
<code class="calibre11"> SELECT </code>
       
<code class="calibre11"> min(market_start_datetime) first_market, </code>
       
<code class="calibre11"> max(market_start_datetime) last_market</code>
   
<code class="calibre11"> FROM farmers_market.datetime_demo</code>
<code class="calibre11">) x</code>
</pre>
<figure class="calibre13">
<img alt="A table records first market, last market, and days first to last." class="center" src="images/000005.png" />
<figcaption class="calibre14">
<p class="calibre8"><span class="figurelabel"><a href="#calibre_link-14" id="calibre_link-13" role="doc-backlink" class="calibre6">Figure 8.7</a></span></p>
</figcaption>
</figure>
<p id="calibre_link-73" class="calibre8">There are additional examples using 
<code class="calibre11">DATEDIFF</code>
 later in this chapter.</p>
</section>

    <section aria-labelledby="head-2-64" class="calibre2"><span id="calibre_link-74" class="calibre"></span>
<h2 id="calibre_link-75" class="calibre9">TIMESTAMPDIFF</h2>
<p class="calibre8"><span aria-label="119" type="pagebreak" id="calibre_link-76" role="doc-pagebreak" class="calibre10"></span>The 
<code class="calibre11">DATEDIFF</code>
 function returns the difference in days, but there is also a function in MySQL called 
<code class="calibre11">TIMESTAMPDIFF</code>
 that returns the difference between two datetimes in any chosen interval. Here, we calculate the hours and minutes between the market start and end times on each market date. The results are shown in <a href="#calibre_link-15" id="calibre_link-16" class="calibre6">Figure 8.8</a>:</p>
<pre id="calibre_link-77" class="calibre12">
<code class="calibre11">SELECT market_start_datetime, market_end_datetime,</code>
   
<code class="calibre11"> TIMESTAMPDIFF(HOUR, market_start_datetime, market_end_datetime) </code>
      
<code class="calibre11"> AS market_duration_hours,</code>
   
<code class="calibre11"> TIMESTAMPDIFF(MINUTE, market_start_datetime, market_end_datetime)</code>
      
<code class="calibre11"> AS market_duration_mins</code>
<code class="calibre11"> FROM farmers_market.datetime_demo</code>
</pre>
<figure class="calibre13">
<img alt="A table records market start date time, market end date time, market duration hours, and market duration minutes." class="center" src="images/000006.png" />
<figcaption class="calibre14">
<p class="calibre8"><span class="figurelabel"><a href="#calibre_link-16" id="calibre_link-15" role="doc-backlink" class="calibre6">Figure 8.8</a></span></p>
</figcaption>
</figure>
<p id="calibre_link-78" class="calibre8">In Oracle SQL, you can simply subtract two datetimes from one another and use the 
<code class="calibre11">EXTRACT</code>
 function to specify which interval you want the result returned in.</p>
<p class="calibre8">In Redshift and MS SQL Server, the 
<code class="calibre11">TIMESTAMPDIFF</code>
 doesn't exist and isn't necessary, because the 
<code class="calibre11">DATEDIFF</code>
 function allows for specification of a datepart interval as a parameter.</p>
<aside class="calibre15">
<div class="top"><hr class="calibre16" /></div>
<section class="feature">
<h3 class="calibre17">NOTE</h3>
<p id="calibre_link-79" class="calibre18">An interesting note about the timestamp values in many database (and other) systems is that they are stored as 32-bit integers “under the hood” that represent the number of seconds since January 1, 1970. Because of this, the latest timestamp that can be stored that fits within 32 bits is 2038-01-19 03:14:07. Timestamps above this value will cause an integer overflow (similar to the “Y2K” issue) until database systems are updated to use a new timestamp standard.</p>
<div class="top"><hr class="calibre16" /></div>
</section>
</aside>
</section>

    <section aria-labelledby="head-2-65" class="calibre2"><span id="calibre_link-80" class="calibre"></span>
<h2 id="calibre_link-81" class="calibre9">Date Functions in Aggregate Summaries and Window Functions</h2>
<p id="calibre_link-82" class="calibre8">In this section, we'll explore a few ways that you can use date functions when summarizing data.</p>
<p id="calibre_link-83" class="calibre8"><span aria-label="120" type="pagebreak" id="calibre_link-84" role="doc-pagebreak" class="calibre10"></span>Let's say we wanted to get a profile of each farmer’s market customer's habits over time. So, we'll want to group the results at the customer level and include some date-related summary information in the output. Our database isn't very heavily populated with example purchases over a long time period yet, but we can use the sample data to demonstrate these concepts.</p>
<p class="calibre8">First, let's get each customer's purchase detail records, particularly the dates on which each customer made purchases. We'll start by querying the database for the records for 
<code class="calibre11">customer_id</code>
 1:</p>
<pre id="calibre_link-85" class="calibre12">
<code class="calibre11">SELECT customer_id, market_date </code>
<code class="calibre11">FROM farmers_market.customer_purchases</code>
<code class="calibre11">WHERE customer_id = 1</code>
</pre>
<p id="calibre_link-86" class="calibre8"><a href="#calibre_link-17" id="calibre_link-18" class="calibre6">Figure 8.9</a> shows all of the purchases made by customer 1 over time. Let's summarize this data and get their earliest purchase date, latest purchase date, and number of different days on which they made a purchase.</p>
<figure class="calibre13">
<img alt="A table records customer id and market date." class="center" src="images/000007.png" />
<figcaption class="calibre14">
<p class="calibre8"><span class="figurelabel"><a href="#calibre_link-18" id="calibre_link-17" role="doc-backlink" class="calibre6">Figure 8.9</a></span></p>
</figcaption>
</figure>
<p class="calibre8">We'll 
<code class="calibre11">GROUP BY customer_id</code>
, use 
<code class="calibre11">MIN</code>
 and 
<code class="calibre11">MAX</code>
 to get the lowest (earliest) and highest (latest) purchase dates, and 
<code class="calibre11">COUNT DISTINCT</code>
 to determine on how many different dates they made purchases:</p>
<pre id="calibre_link-87" class="calibre12">
<code class="calibre11">SELECT customer_id, </code>
   
<code class="calibre11"> MIN(market_date) AS first_purchase, </code>
   
<code class="calibre11"> MAX(market_date) AS last_purchase,</code>
   
<code class="calibre11"> COUNT(DISTINCT market_date) AS count_of_purchase_dates</code>
<code class="calibre11">FROM farmers_market.customer_purchases</code>
<code class="calibre11">WHERE customer_id = 1</code>
<code class="calibre11">GROUP BY customer_id</code>
</pre>
<p id="calibre_link-88" class="calibre8"><a href="#calibre_link-19" id="calibre_link-20" class="calibre6">Figure 8.10</a> shows the output of this query.<span aria-label="121" type="pagebreak" id="calibre_link-89" role="doc-pagebreak" class="calibre10"></span></p>
<figure class="calibre13">
<img alt="A table records customer id, first purchase, last market, and count of purchase dates." class="center" src="images/000008.png" />
<figcaption class="calibre14">
<p class="calibre8"><span class="figurelabel"><a href="#calibre_link-20" id="calibre_link-19" role="doc-backlink" class="calibre6">Figure 8.10</a></span></p>
</figcaption>
</figure>
<p class="calibre8">If we wanted to determine for how long this person has been a customer of the farmer’s market, we can get the difference between the first and last purchase. Note that in this query, we're using a 
<code class="calibre11">DATEDIFF</code>
 on the aggregate 
<code class="calibre11">MIN</code>
 and 
<code class="calibre11">MAX</code>
 dates. Those are still date values, so are therefore valid parameters to pass to the 
<code class="calibre11">DATEDIFF</code>
 function. I'll also remove the customer filter here, so we can see the results for all customers in <a href="#calibre_link-21" id="calibre_link-22" class="calibre6">Figure 8.11</a>:</p>
<pre id="calibre_link-90" class="calibre12">
<code class="calibre11">SELECT customer_id, </code>
   
<code class="calibre11"> MIN(market_date) AS first_purchase, </code>
   
<code class="calibre11"> MAX(market_date) AS last_purchase,</code>
   
<code class="calibre11"> COUNT(DISTINCT market_date) AS count_of_purchase_dates,</code>
   
<code class="calibre11"> DATEDIFF(MAX(market_date), MIN(market_date)) AS days_between_first_last_purchase</code>
<code class="calibre11">FROM farmers_market.customer_purchases</code>
<code class="calibre11">GROUP BY customer_id</code>
</pre>
<figure class="calibre13">
<img alt="A table records customer id, first purchase, last market, and count of purchase dates." class="center" src="images/000009.png" />
<figcaption class="calibre14">
<p class="calibre8"><span class="figurelabel"><a href="#calibre_link-22" id="calibre_link-21" role="doc-backlink" class="calibre6">Figure 8.11</a></span></p>
</figcaption>
</figure>
<p class="calibre8">If we wanted to also know how long it's been since the customer last made a purchase, we can use the 
<code class="calibre11">CURDATE()</code>
 function (which may be called 
<code class="calibre11">CURRENT_DATE</code>
, 
<code class="calibre11">TODAY()</code>
, 
<code class="calibre11">SYSDATE</code>
, or 
<code class="calibre11">GETDATE()</code>
 in your particular database system's SQL syntax; check the documentation). The following query demonstrates its usage. 
<code class="calibre11">CURDATE()</code>
 can be used to represent the current system date in any calculation that requires a date or datetime parameter. Keep in mind that the server's current time might differ from your local time, depending on what time zone it is set to:</p>
<pre id="calibre_link-91" class="calibre12">
<code class="calibre11">SELECT customer_id, </code>
   
<code class="calibre11"> MIN(market_date) AS first_purchase, </code>
   
<code class="calibre11"> MAX(market_date) AS last_purchase,</code>
   
<code class="calibre11"> COUNT(DISTINCT market_date) AS count_of_purchase_dates,</code>
   
<code class="calibre11"> DATEDIFF(MAX(market_date), MIN(market_date)) AS days_between_first_last_purchase,</code>
   
<code class="calibre11"> DATEDIFF(CURDATE(), MAX(market_date)) AS days_since:last_purchase</code>
<code class="calibre11">FROM farmers_market.customer_purchases</code>
<code class="calibre11">GROUP BY customer_id</code>
</pre>
<p class="calibre8">Going back to the window functions covered in <a href="c07.xhtml" class="calibre6">Chapter 7</a>, “Window Functions Frequently Used by Data Scientists,” we can also write a query that gives us the days between each purchase a customer makes. Let's go back to customer 1's detailed purchases (previously shown in <a href="#calibre_link-17" class="calibre6">Figure 8.9</a>) and use both the 
<code class="calibre11">RANK</code>
 <span aria-label="122" type="pagebreak" id="calibre_link-92" role="doc-pagebreak" class="calibre10"></span>and 
<code class="calibre11">LAG</code>
 window functions to retrieve each purchase date, along with the next purchase date, so we can have both values per row to enable us to display both and calculate the time between each:</p>
<pre id="calibre_link-93" class="calibre12">
<code class="calibre11">SELECT customer_id, market_date,</code>
   
<code class="calibre11"> RANK() OVER (PARTITION BY customer_id ORDER BY market_date) AS purchase_number,</code>
   
<code class="calibre11"> LEAD(market_date,1) OVER (PARTITION BY customer_id ORDER BY market_date) </code>
<code class="calibre11">AS next_purchase</code>
<code class="calibre11">FROM farmers_market.customer_purchases</code>
<code class="calibre11">WHERE customer_id = 1</code>
</pre>
<p id="calibre_link-94" class="calibre8">The results of this query are shown in <a href="#calibre_link-23" id="calibre_link-24" class="calibre6">Figure 8.12</a>.</p>
<figure class="calibre13">
<img alt="A table records customer id, market date, purchase number, and next purchase." class="center" src="images/000010.png" />
<figcaption class="calibre14">
<p class="calibre8"><span class="figurelabel"><a href="#calibre_link-24" id="calibre_link-23" role="doc-backlink" class="calibre6">Figure 8.12</a></span></p>
</figcaption>
</figure>
<p id="calibre_link-95" class="calibre8">You can see that we didn't quite accomplish the goal of retrieving each purchase date and the previous purchase date in order to show the time between them, because there are multiple rows with the same date in cases where the customer purchased multiple items on the same date. We can resolve this a few ways.</p>
<p id="calibre_link-96" class="calibre8">One approach is to remove the duplicates by using the 
<code class="calibre11">DISTINCT</code>
 keyword, and then use a 
<code class="calibre11">WHERE</code>
 clause filter to remove rows where the two dates (current and next purchase) are the same (because multiple purchases were made on the same date).</p>
<p id="calibre_link-97" class="calibre8">Another is to remove duplicates in the initial dataset and use a subquery (a query inside a query) to get the date differences. Doing this and moving the window functions to the outer query will also fix the issue of the 
<code class="calibre11">RANK</code>
 counting each purchase, when we really want to count each purchase date.</p>
<p class="calibre8">This is what that second approach looks like:</p>
<pre id="calibre_link-98" class="calibre12">
<code class="calibre11">SELECT </code>
   
<code class="calibre11"> x.customer_id, </code>
   
<code class="calibre11"> x.market_date,</code>
   
<code class="calibre11"> RANK() OVER (PARTITION BY x.customer_id ORDER BY x.market_date) </code>
<code class="calibre11">AS purchase_number,</code>
   
<code class="calibre11"> LEAD(x.market_date,1) OVER (PARTITION BY x.customer_id ORDER BY x.market_date) </code>
<code class="calibre11">AS next_purchase</code>
<span aria-label="123" type="pagebreak" id="calibre_link-99" role="doc-pagebreak" class="calibre10"></span>
<code class="calibre11">FROM</code>
<code class="calibre11">( </code>
   
<code class="calibre11"> SELECT DISTINCT customer_id, market_date</code>
   
<code class="calibre11"> FROM farmers_market.customer_purchases</code>
   
<code class="calibre11"> WHERE customer_id = 1</code>
<code class="calibre11">) x</code>
</pre>
<p class="calibre8">and we can now add a line to the query to use that 
<code class="calibre11">next_purchase</code>
 date in a 
<code class="calibre11">DATEDIFF</code>
 calculation:</p>
<pre id="calibre_link-100" class="calibre12">
<code class="calibre11">SELECT </code>
   
<code class="calibre11"> x.customer_id, </code>
   
<code class="calibre11"> x.market_date,</code>
   
<code class="calibre11"> RANK() OVER (PARTITION BY x.customer_id ORDER BY x.market_date) </code>
      
<code class="calibre11"> AS purchase_number,</code>
   
<code class="calibre11"> LEAD(x.market_date,1) OVER (PARTITION BY x.customer_id ORDER BY x.market_date) </code>
<code class="calibre11">AS next_purchase,</code>
   
<code class="calibre11"> DATEDIFF(</code>
   
<code class="calibre11"> LEAD(x.market_date,1) OVER </code>
   
<code class="calibre11"> (PARTITION BY x.customer_id ORDER BY x.market_date),</code>
   
<code class="calibre11"> x.market_date</code>
   
<code class="calibre11"> ) AS days_between_purchases</code>
<code class="calibre11">FROM</code>
<code class="calibre11">( </code>
   
<code class="calibre11"> SELECT DISTINCT customer_id, market_date</code>
   
<code class="calibre11"> FROM farmers_market.customer_purchases</code>
   
<code class="calibre11"> WHERE customer_id = 1</code>
<code class="calibre11">) x</code>
</pre>
<p id="calibre_link-101" class="calibre8">This may look confusing, but we used the same exact 
<code class="calibre11">LEAD</code>
 function inside the 
<code class="calibre11">DATEDIFF</code>
 as we used in the 
<code class="calibre11">next_purchase</code>
 field above it, and the second 
<code class="calibre11">DATEDIFF</code>
 parameter is just 
<code class="calibre11">market_date</code>
, so we are calculating the days between the current row's 
<code class="calibre11">market_date</code>
 and 
<code class="calibre11">next_purchase</code>
 columns. We can't just insert the 
<code class="calibre11">next_purchase</code>
 column name into the query there; we have to calculate it for the 
<code class="calibre11">days_between_purchases</code>
 field as well, because the calculations don't happen sequentially and are at the same level (the outer query).</p>
<p id="calibre_link-102" class="calibre8">The results of the preceding query are shown in <a href="#calibre_link-25" id="calibre_link-26" class="calibre6">Figure 8.13</a>. You might notice that the final 
<code class="calibre11">days_between_purchases</code>
 value is NULL. That's because that row's 
<code class="calibre11">next_purchase</code>
 date is NULL, since there are no more purchases for customer 1 after March 20, 2019.<span aria-label="124" type="pagebreak" id="calibre_link-103" role="doc-pagebreak" class="calibre10"></span></p>
<figure class="calibre13">
<img alt="A table records customer id, market date, purchase number, and next purchase." class="center" src="images/000011.png" />
<figcaption class="calibre14">
<p class="calibre8"><span class="figurelabel"><a href="#calibre_link-26" id="calibre_link-25" role="doc-backlink" class="calibre6">Figure 8.13</a></span></p>
</figcaption>
</figure>
<p class="calibre8">If we wanted to use the 
<code class="calibre11">next_purchase</code>
 field name inside the 
<code class="calibre11">DATEDIFF()</code>
 function to avoid inserting that 
<code class="calibre11">LEAD()</code>
 calculation twice, we could use another query layer and have a query of a query of a query, as shown in the following code. Here, we'll remove the 
<code class="calibre11">customer_id</code>
 filter to return all customers, then filter to each customer's first purchase by adding a filter on the calculated 
<code class="calibre11">purchase_number</code>
. This query answers the question “How many days pass between each customer's first and second purchase?” The results of this query are shown in <a href="#calibre_link-27" id="calibre_link-28" class="calibre6">Figure 8.14</a>.</p>
<pre id="calibre_link-104" class="calibre12">
<code class="calibre11">SELECT </code>
   
<code class="calibre11"> a.customer_id, </code>
   
<code class="calibre11"> a.market_date AS first_purchase, </code>
   
<code class="calibre11"> a.next_purchase AS second_purchase,</code>
   
<code class="calibre11"> DATEDIFF(a.next_purchase, a.market_date) AS time_between_1st_2nd_purchase</code>
<code class="calibre11">FROM</code>
<code class="calibre11">(</code>
   
<code class="calibre11"> SELECT </code>
      
<code class="calibre11"> x.customer_id, </code>
      
<code class="calibre11"> x.market_date,</code>
      
<code class="calibre11"> RANK() OVER (PARTITION BY x.customer_id ORDER BY x.market_date) </code>
<code class="calibre11">AS purchase_number,</code>
      
<code class="calibre11"> LEAD(x.market_date,1) OVER (PARTITION BY x.customer_id ORDER BY x.market_date) </code>
<code class="calibre11">AS next_purchase</code>
      
<code class="calibre11"> FROM</code>
      
<code class="calibre11"> ( </code>
        
<code class="calibre11"> SELECT DISTINCT customer_id, market_date</code>
        
<code class="calibre11"> FROM farmers_market.customer_purchases</code>
      
<code class="calibre11"> ) x</code>
<code class="calibre11">) a</code>
<code class="calibre11">WHERE a.purchase_number = 1</code>
</pre>
<figure class="calibre13">
<img alt="A table records customer id, market date, purchase number, and next purchase." class="center" src="images/000012.png" />
<figcaption class="calibre14">
<p class="calibre8"><span class="figurelabel"><a href="#calibre_link-28" id="calibre_link-27" role="doc-backlink" class="calibre6">Figure 8.14</a></span></p>
</figcaption>
</figure>
<p id="calibre_link-105" class="calibre8">In <a href="c10.xhtml" class="calibre6">Chapter 10</a>, “Building Analytical Reports with SQL,” we will cover a concept called Common Table Expression, also known as a CTE or “
<code class="calibre11">WITH</code>
 clause,” which offers another way to select from precalculated values instead of nesting <span aria-label="125" type="pagebreak" id="calibre_link-106" role="doc-pagebreak" class="calibre10"></span>multiple queries inside one another as we did earlier, which you can imagine will get increasingly complex and difficult to read as we attempt to answer more complex questions.</p>
<p id="calibre_link-107" class="calibre8">To get back to simpler aggregate functions that use dates, we will again return to customer 1's purchase history (originally shown in <a href="#calibre_link-17" class="calibre6">Figure 8.9</a>). Let's say that today's date is March 31, 2019, and the marketing director of the farmer's market wants to give infrequent customers an incentive to return to the market in April. The director asks you for a list of everyone who only made a purchase at one market event during the previous month, because they want to send an email to all of those customers with a coupon to receive a discount on a purchase made in April. How would you pull up that list?</p>
<p id="calibre_link-108" class="calibre8">Well, first we have to find everyone who made a purchase in the 31 days prior to March 31, 2019. Then, we need to filter that list to those who only made a purchase on a single market date during that time.</p>
<p class="calibre8">This query would retrieve a list of one row per market date per customer within that date range:</p>
<pre id="calibre_link-109" class="calibre12">
<code class="calibre11">SELECT DISTINCT customer_id, market_date </code>
<code class="calibre11">FROM farmers_market.customer_purchases</code>
<code class="calibre11">WHERE DATEDIFF('2019-03-31', market_date) &lt;= 31</code>
</pre>
<p class="calibre8">Then, we could query the results of that query, count the distinct 
<code class="calibre11">market_date</code>
 values per customer during that time, and filter to those with exactly one market date, using the 
<code class="calibre11">HAVING</code>
 clause (which remember is like the 
<code class="calibre11">WHERE</code>
 clause, but calculated after the 
<code class="calibre11">GROUP BY</code>
 aggregation):</p>
<pre id="calibre_link-110" class="calibre12">
<code class="calibre11">SELECT x.customer_id, </code>
   
<code class="calibre11"> COUNT(DISTINCT x.market_date) AS market_count</code>
<code class="calibre11">FROM</code>
<code class="calibre11">(</code>
   
<code class="calibre11"> SELECT DISTINCT customer_id, market_date </code>
   
<code class="calibre11"> FROM farmers_market.customer_purchases</code>
   
<code class="calibre11"> WHERE DATEDIFF('2019-03-31', market_date) &lt;= 31</code>
<code class="calibre11">) x</code>
<code class="calibre11">GROUP BY x.customer_id</code>
<code class="calibre11">HAVING COUNT(DISTINCT market_date) = 1</code>
</pre>
<p id="calibre_link-111" class="calibre8">The results of this query are shown in <a href="#calibre_link-29" id="calibre_link-30" class="calibre6">Figure 8.15</a></p>
<figure class="calibre13">
<img alt="A table records customer id and market count." class="center" src="images/000013.png" />
<figcaption class="calibre14">
<p class="calibre8"><span class="figurelabel"><a href="#calibre_link-30" id="calibre_link-29" role="doc-backlink" class="calibre6">Figure 8.15</a></span></p>
</figcaption>
</figure>
<p id="calibre_link-112" class="calibre8">If we were actually fulfilling a report request, we would want to next join these results to the customer table to get the customer name and contact information, but here we have shown how to use date calculations to filter a list of customers by the actions they took.</p>
</section>

    <section aria-labelledby="head-2-66" class="calibre2"><span id="calibre_link-113" class="calibre"></span>
<h2 id="calibre_link-114" class="calibre9">Exercises</h2>
<ol class="decimal" id="calibre_link-115">
<li id="calibre_link-116" class="calibre19"><span aria-label="126" type="pagebreak" id="calibre_link-117" role="doc-pagebreak" class="calibre10"></span>Get the 
<code class="calibre11">customer_id</code>
, month, and year (in separate columns) of every purchase in the 
<code class="calibre11">farmers_market.customer_purchases</code>
 table.</li>
<li id="calibre_link-118" class="calibre19">Write a query that filters to purchases made in the past two weeks, returns the earliest 
<code class="calibre11">market_date</code>
 in that range as a field called 
<code class="calibre11">sales_since:date</code>
, and a sum of the sales (
<code class="calibre11">quantity * cost_to_customer_per_qty</code>
) during that date range.
<p class="listpara" id="calibre_link-119">Your final answer should use the 
<code class="calibre11">CURDATE()</code>
 function, but if you want to test it out on the Farmer's Market database, you can replace your 
<code class="calibre11">CURDATE()</code>
 with the value 
<code class="calibre11">‘2019-03-31’</code>
 to get the report for the two weeks prior to March 31, 2019 (otherwise your query will not return any data, because none of the dates in the database will have occurred within two weeks of you writing the query).</p></li>
<li id="calibre_link-120" class="calibre19">In MySQL, there is a 
<code class="calibre11">DAYNAME()</code>
 function that returns the full name of the day of the week on which a date occurs. Query the Farmer's Market database 
<code class="calibre11">market_date_info</code>
 table, return the 
<code class="calibre11">market_date</code>
, the 
<code class="calibre11">market_day</code>
, and your calculated day of the week name that each 
<code class="calibre11">market_date</code>
 occurred on. Create a calculated column using a 
<code class="calibre11">CASE</code>
 statement that indicates whether the recorded day in the database differs from your calculated day of the week. This is an example of a quality control query that could be used to check manually entered data for correctness.</li>
</ol>
</section>

  </section>

</div>



</body></html>