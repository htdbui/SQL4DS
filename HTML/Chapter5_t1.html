<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Introduction</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <hr>
<h2 id="title-sql-chapter-5-time-1author-db">title: &quot;SQL Chapter 5 Time 1&quot;
author: &quot;db&quot;</h2>
<h1 id="introduction">Introduction</h1>
<ul>
<li>Now that you know how to select and filter data from a database table, you might wonder how to handle data spread across multiple related tables.
<ul>
<li>For example:
<ul>
<li>The question &quot;When is each type of fresh fruit or vegetable in season, locally?&quot; requires data from multiple tables.
<ul>
<li><code>product_category</code> table: to filter categories</li>
<li><code>product</code> table: for item details</li>
<li><code>vendor_inventory</code> table: to find out when vendors sold these products</li>
</ul>
</li>
</ul>
</li>
<li>This is where SQL <code>JOIN</code>s come in.</li>
</ul>
</li>
</ul>
<h1 id="database-relationships-and-sql-joins">Database Relationships and SQL JOINs</h1>
<ul>
<li>
<p>In Chapter 1, &quot;Data Sources,&quot; we introduced database relationships and the entity-relationship diagram (<code>ERD</code>).</p>
<ul>
<li>Relationships between tables and key fields help us combine them using a <code>JOIN</code> statement in SQL.</li>
<li>For example:
<ul>
<li>To list each product name with its product category name, we need to combine the <code>product</code> and <code>product_category</code> tables.</li>
<li>The <code>product</code> table only has the category ID.</li>
<li>The category name is in the <code>product_category</code> table.</li>
</ul>
</li>
</ul>
</li>
<li>
<p>The following figure shows the one-to-many relationship between the <code>product</code> and <code>product_category</code> tables.</p>
<ul>
<li>Each product belongs to one category.</li>
<li>Each category can contain many products.</li>
<li>The primary key in the <code>product_category</code> table is <code>product_category_id</code>.</li>
<li>Each row in the <code>product</code> table has a <code>product_category_id</code> as a foreign key, identifying the category each product belongs to.</li>
</ul>
</li>
</ul>
<p><img src="file:///c:\Users\tuand\OneDrive - stud.uni-goettingen.de\Attachments\Github\SQL4DS\Fotos\Chapter5\Fig_5.1.png" alt="Figure 5.1"></p>
<figcaption></figcaption>
<ul>
<li>To remind you:
<ul>
<li>An infinity symbol, &quot;N,&quot; or &quot;crow's feet&quot; on the end of a line connecting two tables in an <code>ERD</code> indicates the &quot;many&quot; side of a one-to-many relationship.</li>
</ul>
</li>
<li>To combine these tables:
<ul>
<li>We need to determine which type of <code>JOIN</code> to use.</li>
<li>We'll use the two tables from the Farmer's Market database in the following figure.</li>
<li>Some columns are removed to simplify the illustration.</li>
</ul>
</li>
</ul>
<p><img src="file:///c:\Users\tuand\OneDrive - stud.uni-goettingen.de\Attachments\Github\SQL4DS\Fotos\Chapter5\Fig_5.2.png" alt="Figure 5.2"></p>
<figcaption></figcaption>
<ul>
<li>
<p>This figure shows the one-to-many relationship between these tables.</p>
<ul>
<li>Primary keys are marked with an asterisk.</li>
<li>Foreign keys are marked with a double asterisk.</li>
<li>Each row in the <code>product_category</code> table can be associated with many rows in the <code>product</code> table.</li>
<li>Each row in the <code>product</code> table is associated with only one row in the <code>product_category</code> table.</li>
<li>The fields that connect the two tables are <code>product_category.product_category_id</code> and <code>product.product_category_id</code>.</li>
</ul>
</li>
<li>
<p>The first type of <code>JOIN</code> we'll cover is the <code>LEFT JOIN</code>.</p>
<ul>
<li>This tells the query to pull all records from the table on the &quot;left side&quot; of the <code>JOIN</code>.</li>
<li>It only pulls matching records from the table on the &quot;right side&quot; of the <code>JOIN</code>.</li>
<li>The match is based on the criteria specified in the <code>JOIN</code> clause.</li>
</ul>
</li>
</ul>
<p><img src="file:///c:\Users\tuand\OneDrive - stud.uni-goettingen.de\Attachments\Github\SQL4DS\Fotos\Chapter5\Fig_5.3.png" alt="Figure 5.3"></p>
<figcaption></figcaption>
<ul>
<li>Note that the <code>product</code> table will be on the left side of the <code>JOIN</code> we're setting up.
<ul>
<li>Even though it was on the right side of the relationship diagram.</li>
</ul>
</li>
<li>In the previous figure:
<ul>
<li>There are two records in the <code>product</code> table with a <code>product_category_id</code> of 1.</li>
<li>There is only one record in the <code>product_category</code> table with the <code>product_category_id</code> of 1.</li>
<li>This is because it is the primary key in this table.</li>
</ul>
</li>
<li>When we <code>LEFT JOIN</code> the <code>product_category</code> table to the <code>product</code> table:
<ul>
<li>The records with a value of 1 in the <code>product_category_id</code> fields of both tables will be joined in the results.</li>
<li>The data for <code>product_category_id</code> 1 from the <code>product_category</code> is repeated in two rows in the output.</li>
<li>This is because it matches two records in the <code>product</code> table.</li>
</ul>
</li>
<li>What makes this <code>JOIN</code> a <code>LEFT JOIN</code>:
<ul>
<li>All records from the <code>product</code> table on the left side of the <code>JOIN</code> are included in the output.</li>
<li>Even if they don't have a match in the <code>product_category</code> table.</li>
<li>Records from the <code>product_category</code> table on the right side of the <code>JOIN</code> are only included if they match up with <code>product</code> records on the left side.</li>
</ul>
</li>
<li>In the following figure:
<ul>
<li>The row with a <code>product_id</code> of 99 is included.</li>
<li>The values in the resulting output columns from the <code>product_category</code> are <code>NULL</code>.</li>
<li>This is because there was no <code>product_category_id</code> value on which to join this product to the <code>product_category</code> table.</li>
<li>The row from the <code>product_category</code> table with a <code>product_category_id</code> of 6 is not included in the output at all.</li>
<li>This is because it was in the &quot;right&quot; table and does not have a matching record on the left side.</li>
</ul>
</li>
</ul>
<p><img src="file:///c:\Users\tuand\OneDrive - stud.uni-goettingen.de\Attachments\Github\SQL4DS\Fotos\Chapter5\Fig_5.4.png" alt="Figure 5.4"></p>
<figcaption></figcaption>
<ul>
<li>The syntax for creating this output is:</li>
</ul>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> [columns <span class="hljs-keyword">to</span> <span class="hljs-keyword">return</span>]
<span class="hljs-keyword">FROM</span> [<span class="hljs-keyword">left</span> <span class="hljs-keyword">table</span>]
[<span class="hljs-keyword">JOIN</span> TYPE] [<span class="hljs-keyword">right</span> <span class="hljs-keyword">table</span>]
<span class="hljs-keyword">ON</span> [<span class="hljs-keyword">left</span> <span class="hljs-keyword">table</span>].[field <span class="hljs-keyword">in</span> <span class="hljs-keyword">left</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">match</span>] <span class="hljs-operator">=</span> [<span class="hljs-keyword">right</span> <span class="hljs-keyword">table</span>].[field <span class="hljs-keyword">in</span> <span class="hljs-keyword">right</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">match</span>]
</code></pre>
<ul>
<li>To pull a list of all products with each product's category name listed:
<ul>
<li>Make the <code>product</code> table the &quot;left&quot; table in this query.</li>
<li>List it first after <code>FROM</code>.</li>
<li>Make the <code>product_category</code> table the &quot;right&quot; table.</li>
<li>List it after the <code>LEFT JOIN</code>.</li>
<li>Match up the records using the <code>product_category_id</code> fields.</li>
<li>This is done after the <code>ON</code> keyword.</li>
</ul>
</li>
</ul>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> product 
    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> product_category
         <span class="hljs-keyword">ON</span> product.product_category_id <span class="hljs-operator">=</span> product_category.product_category_id
</code></pre>
<ul>
<li>This query can be read as:
<ul>
<li>&quot;Select everything from the <code>product</code> table.&quot;</li>
<li>&quot;Left joined with the <code>product_category</code> table.&quot;</li>
<li>&quot;Matched on the <code>product_category_id</code> that's common to both tables.&quot;</li>
</ul>
</li>
<li>More specifically:
<ul>
<li>&quot;Select all columns and rows from the <code>product</code> table.&quot;</li>
<li>&quot;And all columns from the <code>product_category</code> table.&quot;</li>
<li>&quot;For rows where the <code>product_category</code>'s <code>product_category_id</code> matches a <code>product</code>'s <code>product_category_id</code>.&quot;</li>
</ul>
</li>
<li>The following figure shows the first 10 rows of the output from this query.</li>
</ul>
<p><img src="file:///c:\Users\tuand\OneDrive - stud.uni-goettingen.de\Attachments\Github\SQL4DS\Fotos\Chapter5\Fig_5.5.png" alt="Figure 5.5"></p>
<figcaption></figcaption>
<ul>
<li>You may have noticed two <code>product_category_id</code> columns in the previous figure.
<ul>
<li>This is because we selected all fields using the asterisk.</li>
<li>Both tables have a field with the same name.</li>
<li>To fix this, specify the fields to return.</li>
<li>Include <code>product_category_id</code> from only one table.</li>
<li>Or alias the column names to indicate which table each came from.</li>
</ul>
</li>
<li>The <code>LEFT JOIN</code> indicates:
<ul>
<li>We want all rows from the <code>product</code> table (left side).</li>
<li>Only the associated rows from the <code>product_category</code> table.</li>
<li>If there is a category not associated with any products, it will not be included in the results.</li>
<li>If there is a product without a category, it will be included in the results.</li>
<li>The fields on the <code>product_category</code> side will be <code>NULL</code>.</li>
</ul>
</li>
<li>The <code>ON</code> clause matches rows in the two tables using the <code>product_category_id</code> field.
<ul>
<li>The <code>product_category_id</code> fields from both tables match on every row.</li>
</ul>
</li>
<li>To retrieve specific columns from the merged dataset:
<ul>
<li>Specify which table each column is from.</li>
<li>Different tables can have identically named columns.</li>
<li>Alias these columns to differentiate them.</li>
<li>The following code shows this.</li>
</ul>
</li>
</ul>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> 
    product.product_id,
    product.product_name,
    product.product_category_id <span class="hljs-keyword">AS</span> product_prod_cat_id, 
    product_category.product_category_id <span class="hljs-keyword">AS</span> category_prod_cat_id, 
    product_category.product_category_name
<span class="hljs-keyword">FROM</span> product 
    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> product_category 
         <span class="hljs-keyword">ON</span> product.product_category_id <span class="hljs-operator">=</span> product_category. 
product_category_id
</code></pre>
<p><img src="file:///c:\Users\tuand\OneDrive - stud.uni-goettingen.de\Attachments\Github\SQL4DS\Fotos\Chapter5\Fig_5.6.png" alt="Figure 5.6"></p>
<figcaption></figcaption>
<ul>
<li>There is another type of aliasing in a SQL query for developer convenience: table aliasing.
<ul>
<li>If you don't want to write out the entire table name every time you reference it, you can assign it a short alias in the <code>FROM</code> clause.</li>
<li>This alias can then be used throughout the query.</li>
<li>The following query demonstrates this with the table aliases <code>p</code> and <code>pc</code>.</li>
</ul>
</li>
</ul>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> 
    p.product_id,
    p.product_name,  
    pc.product_category_id, 
    pc.product_category_name
<span class="hljs-keyword">FROM</span> product <span class="hljs-keyword">AS</span> p 
    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> product_category <span class="hljs-keyword">AS</span> pc
         <span class="hljs-keyword">ON</span> p.product_category_id <span class="hljs-operator">=</span> pc.product_category_id 
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> pc.product_category_name, p.product_name
</code></pre>
<ul>
<li>To remind, the <code>AS</code> keyword is optional.</li>
</ul>
<p><img src="file:///c:\Users\tuand\OneDrive - stud.uni-goettingen.de\Attachments\Github\SQL4DS\Fotos\Chapter5\Fig_5.7.png" alt="Figure 5.7"></p>
<figcaption></figcaption>
<ul>
<li>The next type of SQL <code>JOIN</code> is a <code>RIGHT JOIN</code>.
<ul>
<li>It returns all rows from the &quot;right table&quot;.</li>
<li>It only returns the matching rows from the &quot;left table&quot;.</li>
<li>This is based on the fields specified in the <code>ON</code> clause.</li>
</ul>
</li>
</ul>
<p><img src="file:///c:\Users\tuand\OneDrive - stud.uni-goettingen.de\Attachments\Github\SQL4DS\Fotos\Chapter5\Fig_5.8.png" alt="Figure 5.8"></p>
<figcaption></figcaption>
<ul>
<li>
<p>If we use a <code>RIGHT JOIN</code> to merge the tables shown in the previous figure:</p>
<ul>
<li>The result will look like the table in the following figure.</li>
<li>All records from the &quot;right table,&quot; <code>product_category</code>, are returned.</li>
<li>Only matching records from <code>product</code> are returned.</li>
<li>There are no products with a <code>product_category_id</code> of 6.</li>
<li>So the first three columns of the last row are <code>NULL</code>.</li>
</ul>
</li>
<li>
<p>You would use a <code>RIGHT JOIN</code> to:</p>
<ul>
<li>List all product categories and their products.</li>
<li>Ignore products not in a category.</li>
</ul>
</li>
</ul>
<p><img src="file:///c:\Users\tuand\OneDrive - stud.uni-goettingen.de\Attachments\Github\SQL4DS\Fotos\Chapter5\Fig_5.9.png" alt="Figure 5.9"></p>
<figcaption></figcaption>
<ul>
<li>The next type of JOIN is the INNER JOIN. This JOIN returns only the rows that have matching values in both tables.</li>
</ul>
<p><img src="file:///c:\Users\tuand\OneDrive - stud.uni-goettingen.de\Attachments\Github\SQL4DS\Fotos\Chapter5\Fig_5.10.png" alt="Figure 5.10"></p>
<figcaption></figcaption>
<ul>
<li>We use an INNER JOIN in the following figure:</li>
</ul>
<p><img src="file:///c:\Users\tuand\OneDrive - stud.uni-goettingen.de\Attachments\Github\SQL4DS\Fotos\Chapter5\Fig_5.11.png" alt="Figure 5.11"></p>
<figcaption></figcaption>
<ul>
<li>
<p>In the output:</p>
<ul>
<li>Only the rows with matching <code>product_category_id</code> values are included.</li>
</ul>
</li>
<li>
<p>The last type of JOIN is the FULL JOIN.</p>
<ul>
<li>This JOIN returns all rows when there is a match in one of the tables.</li>
<li>It returns <code>NULL</code> values when there is no match.</li>
</ul>
</li>
</ul>
<h2 id="illustration">Illustration</h2>
<ul>
<li>To practice these <code>JOIN</code> types, let's look at the <code>customer</code> and <code>customer_purchase</code> tables from the Farmer's Market database.
<ul>
<li>This is a one-to-many relationship.</li>
<li>A customer can have multiple purchases.</li>
<li>Each purchase is made by only one customer.</li>
<li>The tables are related via the <code>customer_id</code> field.</li>
<li><code>customer_id</code> is the primary key in the <code>customer</code> table.</li>
<li>It is a foreign key in the <code>customer_purchase</code> table.</li>
</ul>
</li>
<li>Using a <code>LEFT JOIN</code> with the following query:
<ul>
<li>We see in the output that some rows have <code>NULL</code> values.</li>
</ul>
</li>
</ul>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> 
<span class="hljs-keyword">FROM</span> customer <span class="hljs-keyword">AS</span> c
<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> customer_purchases <span class="hljs-keyword">AS</span> cp
    <span class="hljs-keyword">ON</span> c.customer_id <span class="hljs-operator">=</span> cp.customer_id
</code></pre>
<p><img src="file:///c:\Users\tuand\OneDrive - stud.uni-goettingen.de\Attachments\Github\SQL4DS\Fotos\Chapter5\Fig_5.12.png" alt="Figure 5.12"></p>
<figcaption></figcaption>
<ul>
<li>Unlike the <code>product</code>-<code>product_category</code> relationship, there can be customers without any purchases.
<ul>
<li>These customers were added to the <code>customer</code> table when they signed up for the farmer’s market loyalty card.</li>
<li>We have their data, but they haven't purchased any products yet.</li>
<li>With a <code>LEFT JOIN</code>, we get a list of all customers and their associated purchases, if any.</li>
<li>Customers with multiple purchases appear multiple times—once for each purchase.</li>
<li>Customers without purchases have <code>NULL</code> values in fields from the <code>customer_purchases</code> table.</li>
<li>We can use the <code>WHERE</code> clause to filter the list to only customers with no purchases, if desired.</li>
</ul>
</li>
</ul>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> c.<span class="hljs-operator">*</span> 
<span class="hljs-keyword">FROM</span> customer <span class="hljs-keyword">AS</span> c
<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> customer_purchases <span class="hljs-keyword">AS</span> cp
    <span class="hljs-keyword">ON</span> c.customer_id <span class="hljs-operator">=</span> cp.customer_id 
<span class="hljs-keyword">WHERE</span> cp.customer_id <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>
</code></pre>
<p><img src="file:///c:\Users\tuand\OneDrive - stud.uni-goettingen.de\Attachments\Github\SQL4DS\Fotos\Chapter5\Fig_5.13.png" alt="Figure 5.13"></p>
<figcaption></figcaption>
<ul>
<li>In this case, we only selected columns from the <code>customer</code> table using <code>c.*</code>.
<ul>
<li>All columns from the <code>customer_purchases</code> table will be <code>NULL</code>.</li>
<li>Remember, every purchase is logged at checkout, and every customer uses their loyalty card.</li>
</ul>
</li>
<li>What if we wanted to list all purchases and the associated customers?
<ul>
<li>We could use a <code>RIGHT JOIN</code> to pull all records from the <code>customer_purchases</code> table.</li>
<li>Only customers from the <code>customer</code> table who have made a purchase will be included.</li>
</ul>
</li>
</ul>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> 
<span class="hljs-keyword">FROM</span> customer <span class="hljs-keyword">AS</span> c
<span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> customer_purchases <span class="hljs-keyword">AS</span> cp
    <span class="hljs-keyword">ON</span> c.customer_id <span class="hljs-operator">=</span> cp.customer_id
</code></pre>
<p><img src="file:///c:\Users\tuand\OneDrive - stud.uni-goettingen.de\Attachments\Github\SQL4DS\Fotos\Chapter5\Fig_5.14.png" alt="Figure 5.14"></p>
<figcaption></figcaption>
<ul>
<li>The output is truncated to save space and doesn’t show all results.
<ul>
<li>There are no rows with <code>NULL</code> values in the <code>customer</code> table columns.</li>
<li>This is because every purchase has a <code>customer_id</code>.</li>
<li>With a <code>RIGHT JOIN</code>, customers without purchases are not included in the results.</li>
</ul>
</li>
<li>If you only want records that have matches in both tables, use an <code>INNER JOIN</code>.
<ul>
<li>With the <code>customer</code> and <code>customer_purchases</code> tables, an <code>INNER JOIN</code> returns the same results as the <code>RIGHT JOIN</code>.</li>
<li>This is because every purchase is associated with a customer.</li>
</ul>
</li>
</ul>
<h1 id="a-common-pitfall-when-filtering-joined-data">A Common Pitfall when Filtering Joined Data</h1>
<ul>
<li>Going back to the <code>LEFT JOIN</code> example between the <code>customer</code> and <code>customer_purchases</code> tables shown in the previous figure:
<ul>
<li>How do you think the output of the following query will differ from the original <code>LEFT JOIN</code> query without the added <code>WHERE</code> clause?</li>
</ul>
</li>
</ul>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> 
<span class="hljs-keyword">FROM</span> customer <span class="hljs-keyword">AS</span> c
<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> customer_purchases <span class="hljs-keyword">AS</span> cp
    <span class="hljs-keyword">ON</span> c.customer_id <span class="hljs-operator">=</span> cp.customer_id 
<span class="hljs-keyword">WHERE</span> cp.customer_id <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>
</code></pre>
<ul>
<li>All <code>customer_id</code> values are integers above 0.
<ul>
<li>It might seem like adding this <code>WHERE</code> clause will make no difference.</li>
<li>However, it filters on the <code>customer_id</code> in the <code>customer_purchases</code> table (alias <code>cp</code>).</li>
<li>This means customers without purchases will be filtered out.</li>
<li>The query will return results like an <code>INNER JOIN</code> instead of a <code>LEFT JOIN</code>.</li>
<li>It will exclude records with <code>NULL</code> values in the <code>customer_purchases</code> table.</li>
<li>So, instead of the output shown in Figure 5.12, this query’s output would look like Figure 5.14.</li>
</ul>
</li>
<li>If you use a <code>LEFT JOIN</code> to return all rows from the &quot;left&quot; table:
<ul>
<li>Avoid filtering on fields from the &quot;right&quot; table without allowing <code>NULL</code> results.</li>
<li>Otherwise, you will filter out rows you intended to keep.</li>
</ul>
</li>
<li>Let's write a query to return a list of all customers who did not make a purchase at the March 2, 2019, farmer's market.
<ul>
<li>We'll use a <code>LEFT JOIN</code> to include customers who have never made a purchase.</li>
<li>These customers have no records in the <code>customer_purchases</code> table.</li>
</ul>
</li>
</ul>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> c.<span class="hljs-operator">*</span>, cp.market_date 
<span class="hljs-keyword">FROM</span> customer <span class="hljs-keyword">AS</span> c
<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> customer_purchases <span class="hljs-keyword">AS</span> cp
    <span class="hljs-keyword">ON</span> c.customer_id <span class="hljs-operator">=</span> cp.customer_id 
<span class="hljs-keyword">WHERE</span> cp.market_date <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;2019-03-02&#x27;</span>
</code></pre>
<p><img src="file:///c:\Users\tuand\OneDrive - stud.uni-goettingen.de\Attachments\Github\SQL4DS\Fotos\Chapter5\Fig_5.15.png" alt="Figure 5.15"></p>
<figcaption></figcaption>
<ul>
<li>The first problem is that we’re missing customers who have never made a purchase, like Betty Bullard shown in Figure 5.12.
<ul>
<li>This is because we filtered on the <code>market_date</code> field from the <code>customer_purchases</code> table, which is on the &quot;right side&quot; of the <code>JOIN</code>.</li>
<li>SQL doesn’t evaluate value comparisons to TRUE when comparing <code>NULL</code> values.</li>
<li>But we need that filter to remove customers who made a purchase that day.</li>
<li>One solution is to write the <code>WHERE</code> clause to allow <code>NULL</code> values in the field.</li>
</ul>
</li>
</ul>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> c.<span class="hljs-operator">*</span>, cp.market_date  
<span class="hljs-keyword">FROM</span> customer <span class="hljs-keyword">AS</span> c
<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> customer_purchases <span class="hljs-keyword">AS</span> cp
    <span class="hljs-keyword">ON</span> c.customer_id <span class="hljs-operator">=</span> cp.customer_id
<span class="hljs-keyword">WHERE</span> (cp.market_date <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;2019-03-02&#x27;</span> <span class="hljs-keyword">OR</span> cp.market_date <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>)
</code></pre>
<p><img src="file:///c:\Users\tuand\OneDrive - stud.uni-goettingen.de\Attachments\Github\SQL4DS\Fotos\Chapter5\Fig_5.16.png" alt="Figure 5.16"></p>
<figcaption></figcaption>
<ul>
<li>Now we see customers without purchases in Figure 5.16, like Betty Bullard.
<ul>
<li>We also see customers who made purchases on other dates.</li>
</ul>
</li>
<li>The other problem is that the output contains one row per customer per item purchased.
<ul>
<li>We just want a list of customers.</li>
<li>We can fix this by removing the <code>market_date</code> field from the <code>customer_purchases</code> table.</li>
<li>Use the <code>DISTINCT</code> keyword to remove duplicate records.</li>
</ul>
</li>
<li>Figure 5.17 shows the output of the following query:</li>
</ul>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> c.<span class="hljs-operator">*</span>  
<span class="hljs-keyword">FROM</span> customer <span class="hljs-keyword">AS</span> c
<span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> customer_purchases <span class="hljs-keyword">AS</span> cp
    <span class="hljs-keyword">ON</span> c.customer_id <span class="hljs-operator">=</span> cp.customer_id
<span class="hljs-keyword">WHERE</span> (cp.market_date <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-string">&#x27;2019-03-02&#x27;</span> <span class="hljs-keyword">OR</span> cp.market_date <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>)
</code></pre>
<p><img src="file:///c:\Users\tuand\OneDrive - stud.uni-goettingen.de\Attachments\Github\SQL4DS\Fotos\Chapter5\Fig_5.17.png" alt="Figure 5.17"></p>
<figcaption></figcaption>
<ul>
<li>With this approach:
<ul>
<li>We filtered out unwanted records using values from the <code>customer_purchases</code> table.</li>
<li>We did not exclude desired records from the <code>customer</code> table.</li>
<li>We only displayed data from one table, even though we used fields from both in the query.</li>
</ul>
</li>
</ul>
<h1 id="joins-with-more-than-two-tables">JOINs with More than Two Tables</h1>
<ul>
<li>Let's say we want details about all farmer’s market booths and every vendor booth assignment for every market date.
<ul>
<li>We might be building an interactive report.</li>
<li>The report can filter by booth, vendor, or date.</li>
<li>It shows booth assignments with additional booth and vendor details.</li>
<li>This requires joining the three tables shown in Figure 5.18.</li>
</ul>
</li>
</ul>
<p><img src="file:///c:\Users\tuand\OneDrive - stud.uni-goettingen.de\Attachments\Github\SQL4DS\Fotos\Chapter5\Fig_5.18.png" alt="Figure 5.18"></p>
<figcaption></figcaption>
<ul>
<li>What <code>JOIN</code>s could we use to ensure all booths are included, even if they aren’t assigned to a vendor yet, and all vendors assigned to booths are included?
<ul>
<li>We can <code>LEFT JOIN</code> <code>vendor_booth_assignments</code> to <code>booth</code>, including all booths.</li>
<li><code>LEFT JOIN</code> <code>vendor</code> to <code>vendor_booth_assignments</code>.</li>
<li>The query looks like this and results in Figure 5.19:</li>
</ul>
</li>
</ul>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> 
    b.booth_number,
    b.booth_type,
    vba.market_date, 
    v.vendor_id, 
    v.vendor_name, 
    v.vendor_type
<span class="hljs-keyword">FROM</span> booth <span class="hljs-keyword">AS</span> b 
    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> vendor_booth_assignments <span class="hljs-keyword">AS</span> vba <span class="hljs-keyword">ON</span> b.booth_number <span class="hljs-operator">=</span> vba.
booth_number
    <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> vendor <span class="hljs-keyword">AS</span> v <span class="hljs-keyword">ON</span> v.vendor_id <span class="hljs-operator">=</span> vba.vendor_id
<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> b.booth_number, vba.market_date
</code></pre>
<p><img src="file:///c:\Users\tuand\OneDrive - stud.uni-goettingen.de\Attachments\Github\SQL4DS\Fotos\Chapter5\Fig_5.19.png" alt="Figure 5.19"></p>
<figcaption></figcaption>
<ul>
<li>You can think of the second <code>JOIN</code> as being merged into the result of the first <code>JOIN</code>.
<ul>
<li>The <code>vendor_id</code> field in the <code>vendor</code> table is joined to the <code>vendor_id</code> field in the <code>vendor_booth_assignments</code> table.</li>
<li>Only vendors that exist in the <code>vendor_booth_assignments</code> table are included in the output.</li>
<li>This is shown in Figure 5.20.</li>
</ul>
</li>
</ul>
<p><img src="file:///c:\Users\tuand\OneDrive - stud.uni-goettingen.de\Attachments\Github\SQL4DS\Fotos\Chapter5\Fig_5.20.png" alt="Figure 5.20"></p>
<figcaption></figcaption>
<ul>
<li>If the third table was joined to the first table using a common field:
<ul>
<li>This case is common but not possible with the tables in this Farmer’s Market database.</li>
<li>There aren’t any other tables joined to the <code>booth</code> table.</li>
<li>The arrangement would look like the diagram in Figure 5.21.</li>
</ul>
</li>
</ul>
<p><img src="file:///c:\Users\tuand\OneDrive - stud.uni-goettingen.de\Attachments\Github\SQL4DS\Fotos\Chapter5\Fig_5.21.png" alt="Figure 5.21"></p>
<figcaption></figcaption>
<ul>
<li>
<p>This method of joining multiple tables is common in machine learning applications.</p>
<ul>
<li>You have one primary table with one row per entity.</li>
<li>Many other tables are <code>LEFT JOIN</code>ed to it.</li>
<li>This allows you to pull additional data about the entity from other tables.</li>
<li>Data in these other tables is often summarized.</li>
<li>The resulting dataset remains at one row per entity.</li>
<li>Data from other tables is represented by counts or sums.</li>
</ul>
</li>
<li>
<p>You will learn more about this in Chapter 6, &quot;Aggregating Results for Analysis,&quot; when we cover aggregation.</p>
</li>
<li>
<p>We will continue to use <code>JOIN</code>s throughout the book, so look for more examples in later chapters.</p>
</li>
</ul>
<h1 id="exercises">Exercises</h1>
<ol>
<li>
<p>Write a query that <code>INNER JOIN</code>s the <code>vendor</code> table to the <code>vendor_booth_assignments</code> table on the <code>vendor_id</code> field they have in common.</p>
<ul>
<li>Sort the result by <code>vendor_name</code>, then <code>market_date</code>.</li>
</ul>
</li>
<li>
<p>Write a query that produces the same output as the following query but uses a <code>LEFT JOIN</code> instead of a <code>RIGHT JOIN</code>:</p>
</li>
</ol>
<pre><code class="language-sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> 
<span class="hljs-keyword">FROM</span> customer <span class="hljs-keyword">AS</span> c
<span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> customer_purchases <span class="hljs-keyword">AS</span> cp
    <span class="hljs-keyword">ON</span> c.customer_id <span class="hljs-operator">=</span> cp.customer_id
</code></pre>
<ol start="3">
<li>To answer the question &quot;When is each type of fresh fruit or vegetable in season, locally?&quot; we need data from:
<ul>
<li>The <code>product_category</code> table</li>
<li>The <code>product</code> table</li>
<li>The <code>vendor_inventory</code> table
What type of <code>JOIN</code>s would be needed to combine these three tables?</li>
</ul>
</li>
</ol>

            
            
        </body>
        </html>